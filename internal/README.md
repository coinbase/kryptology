<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# internal

```go
import "github.com/coinbase/kryptology/internal"
```

## Index

- [Variables](<#variables>)
- [func AssertBigIntEq(t *testing.T, a, b *big.Int)](<#func-assertbiginteq>)
- [func AssertBigIntNe(t *testing.T, a, b *big.Int)](<#func-assertbigintne>)
- [func AssertError(t *testing.T, err error, msg string)](<#func-asserterror>)
- [func AssertNil(t *testing.T, values ...*big.Int)](<#func-assertnil>)
- [func AssertNoError(t *testing.T, err error)](<#func-assertnoerror>)
- [func AssertNotNil(t *testing.T, values ...*big.Int)](<#func-assertnotnil>)
- [func AssertSomeError(t *testing.T, err error)](<#func-assertsomeerror>)
- [func B10(s string) *big.Int](<#func-b10>)
- [func BigInt2Ed25519Point(y *big.Int) (*edwards25519.Point, error)](<#func-bigint2ed25519point>)
- [func BigInt2Ed25519Scalar(x *big.Int) (*edwards25519.Scalar, error)](<#func-bigint2ed25519scalar>)
- [func ByteSub(b []byte)](<#func-bytesub>)
- [func CalcFieldSize(curve elliptic.Curve) int](<#func-calcfieldsize>)
- [func Hash(info []byte, values ...[]byte) ([]byte, error)](<#func-hash>)
- [func ReverseScalarBytes(inBytes []byte) []byte](<#func-reversescalarbytes>)


## Variables

```go
var (
    ErrNotOnCurve           = fmt.Errorf("point not on the curve")
    ErrPointsDistinctCurves = fmt.Errorf("points must be from the same curve")
    ErrZmMembership         = fmt.Errorf("x âˆ‰ Z_m")
    ErrResidueOne           = fmt.Errorf("value must be 1 (mod N)")
    ErrNCannotBeZero        = fmt.Errorf("N cannot be 0")
    ErrNilArguments         = fmt.Errorf("arguments cannot be nil")
    ErrZeroValue            = fmt.Errorf("arguments cannot be 0")
    ErrInvalidRound         = fmt.Errorf("invalid round method called")
    ErrIncorrectCount       = fmt.Errorf("incorrect number of inputs")
    ErrInvalidJson          = fmt.Errorf("json format does not contain the necessary data")
)
```

## func [AssertBigIntEq](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L42>)

```go
func AssertBigIntEq(t *testing.T, a, b *big.Int)
```

AssertBigIntEq fails the test if a and b are not equal

## func [AssertBigIntNe](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L55>)

```go
func AssertBigIntNe(t *testing.T, a, b *big.Int)
```

AssertBigIntNe fails the test if two big\.Ints are the same value

## func [AssertError](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L30>)

```go
func AssertError(t *testing.T, err error, msg string)
```

AssertError fails the test if err == nil or the message does not equal msg

## func [AssertNil](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L77>)

```go
func AssertNil(t *testing.T, values ...*big.Int)
```

AssertNil fails the test if any of values are nil

## func [AssertNoError](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L15>)

```go
func AssertNoError(t *testing.T, err error)
```

AssertNoError FailsNow\(\) the test if err \!= nil

## func [AssertNotNil](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L68>)

```go
func AssertNotNil(t *testing.T, values ...*big.Int)
```

AssertNotNil fails if any values are nil

## func [AssertSomeError](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L23>)

```go
func AssertSomeError(t *testing.T, err error)
```

AssertSomeError fails the test if err == nil

## func [B10](<https://github.com/coinbase/kryptology/blob/master/internal/testutils.go#L87>)

```go
func B10(s string) *big.Int
```

B10 creating a big\.Int from a base 10 string\. panics on failure to to ensure zero\-values aren't used in place of malformed strings\.

## func [BigInt2Ed25519Point](<https://github.com/coinbase/kryptology/blob/master/internal/point.go#L31>)

```go
func BigInt2Ed25519Point(y *big.Int) (*edwards25519.Point, error)
```

## func [BigInt2Ed25519Scalar](<https://github.com/coinbase/kryptology/blob/master/internal/point.go#L38>)

```go
func BigInt2Ed25519Scalar(x *big.Int) (*edwards25519.Scalar, error)
```

## func [ByteSub](<https://github.com/coinbase/kryptology/blob/master/internal/hash.go#L74>)

```go
func ByteSub(b []byte)
```

ByteSub is a constant time algorithm for subtracting 1 from the array as if it were a big number\. 0 is considered a wrap which resets to 0xFF

## func [CalcFieldSize](<https://github.com/coinbase/kryptology/blob/master/internal/point.go#L16>)

```go
func CalcFieldSize(curve elliptic.Curve) int
```

## func [Hash](<https://github.com/coinbase/kryptology/blob/master/internal/hash.go#L36>)

```go
func Hash(info []byte, values ...[]byte) ([]byte, error)
```

### Hash computes the HKDF over many values
iteratively such that each value is hashed separately
and based on preceding values

The first value is computed as okm\_0 = KDF\(f || value\) where
f is a byte slice of 32 0xFF
salt is zero\-filled byte slice with length equal to the hash output length
info is the protocol name
okm is the 32 byte output

The each subsequent iteration is computed by as okm\_i = KDF\(f\_i || value || okm\_\{i\-1\}\) where f\_i = 2^b \- 1 \- i such that there are 0xFF bytes prior to the value\. f\_1 changes the first byte to 0xFE\, f\_2 to 0xFD\. The previous okm is appended to the value to provide cryptographic domain separation. See https://signal.org/docs/specifications/x3dh/#cryptographic-notation and https://signal.org/docs/specifications/xeddsa/#hash-functions for more details\. This uses the KDF function similar to X3DH for each \`value\` But changes the key just like XEdDSA where the prefix bytes change by a single bit

## func [ReverseScalarBytes](<https://github.com/coinbase/kryptology/blob/master/internal/point.go#L21>)

```go
func ReverseScalarBytes(inBytes []byte) []byte
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
